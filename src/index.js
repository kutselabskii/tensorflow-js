import './css/style.css'
import './css/simple-grid.css'

import * as tf from '@tensorflow/tfjs';

import * as images from './js/images';
import * as models from './js/models';

const size = [512, 512];

var webcamButton = undefined;
var video = undefined;
var canvasElement = undefined;
var modelButton = undefined;
var fps = undefined;
var webcam = undefined;
var videoSourcesSelect = undefined;
var modelSourcesSelect = undefined;
var currentImage = 0;

const availableModels = [new models.LinkNet(size), new models.FastSCNN(size), new models.UNet(size)];

initialize();

function initialize() {
  prepareElements();
  prepareVideoSources();
  prepareModelSources();

  images.prepareTextureTensors(size);
}

function prepareElements() {
  webcamButton = document.getElementById('webcamButton');
  video = document.getElementById('webcam');
  canvasElement = document.getElementById('canvas');
  modelButton = document.getElementById('modelButton');
  fps = document.getElementById('fps');
  videoSourcesSelect = document.getElementById("video-source");
  modelSourcesSelect = document.getElementById("model-source");

  prepareImages();  // TODO Images may be generated by code
}

function prepareImages() {
  for (let i = 0; i < images.textures.length; ++i) {
    const enclosedIndex = i;
    const img = document.getElementById('texture-' + i);

    img.addEventListener('click', () => {
      if (enclosedIndex == currentImage) {
        return;
      }

      document.getElementById('texture-' + currentImage).classList.remove('highlight');
      img.classList.add('highlight');
      currentImage = enclosedIndex;
    });
  }
}

function prepareModelSources() {
  for (let i = 0; i < availableModels.length; ++i) {
    let option = new Option();
    option.value = i;
    option.text = availableModels[i].name;
    modelSourcesSelect.appendChild(option);
  }
}

function prepareVideoSources() {
  navigator.mediaDevices.enumerateDevices().then((devices) => {
    devices.forEach((device) => {
        let option = new Option();
        option.value = device.deviceId;

        if (device.kind == "videoinput") {
          option.text = device.label || `Camera ${videoSourcesSelect.length + 1}`;
          videoSourcesSelect.appendChild(option);  
        }
    });
  }).catch(function (e) {
    console.log(e.name + ": " + e.message);
  });
}

modelButton.addEventListener('click', modelButtonClicked);
async function modelButtonClicked() {
  await availableModels[modelSourcesSelect.value].load();

  modelButton.classList.add("removed");
  document.getElementById("model-source-label").classList.add("removed");
  modelSourcesSelect.classList.add("removed");

  webcamButton.classList.remove("removed");
  document.getElementById("video-source-label").classList.remove("removed");
  videoSourcesSelect.classList.remove("removed");
}

webcamButton.addEventListener('click', webcamButtonClicked);
function webcamButtonClicked() {
  document.getElementById("camera-icon").classList.add("removed");
  video.classList.remove("removed");

  document.getElementById("sofa-icon").classList.add("removed");
  canvasElement.classList.remove("removed");
  fps.classList.remove("removed");

  webcamButton.classList.add("removed");
  document.getElementById("video-source-label").classList.add("removed");
  document.getElementById("video-source").classList.add("removed");

  const videoSource = videoSourcesSelect.value;
  const constraints = {
    video: {
      width: size[0],
      height: size[1],
      deviceId: videoSource ? {exact: videoSource} : undefined
    }
  };

  navigator.mediaDevices.getUserMedia(constraints).then(async function(stream) {
    video.srcObject = stream;
    video.addEventListener('loadeddata', predictWebcam);
    webcam = await tf.data.webcam(video, {
      facingMode: "environment",
      deviceId: videoSource ? videoSource : undefined
    });
    availableModels[modelSourcesSelect.value].setScreens(webcam, canvasElement);
  });
}

async function predictWebcam() {
  const time = await availableModels[modelSourcesSelect.value].predict(images.tensors[currentImage]);

  if (time < 0) {
    return;
  }

  fps.textContent = "Elapsed time: " + (time / 1000) + " seconds";

  window.requestAnimationFrame(predictWebcam);
}