import './css/style.css'
import './css/simple-grid.css'

import * as images from './js/images';

import * as tf from '@tensorflow/tfjs';
import { ResizeLayer } from './js/layers';
import { recolor } from './js/recoloring';

const NN_SIZE = [128, 128];
const ORIG_SIZE = [512, 512];

var webcamButton = undefined;
var video = undefined;
var canvasElement = undefined;
var modelButton = undefined;
var fps = undefined;
var model = undefined;
var webcam = undefined;
var videoSourcesSelect = undefined;
var currentImage = 0;

initialize();

function initialize() {
  prepareElements();
  prepareVideoSources();

  images.prepareTextureTensors(ORIG_SIZE);
}

function prepareElements() {
  webcamButton = document.getElementById('webcamButton');
  video = document.getElementById('webcam');
  canvasElement = document.getElementById('canvas');
  modelButton = document.getElementById('modelButton');
  fps = document.getElementById('fps');
  videoSourcesSelect = document.getElementById("video-source");

  prepareImages();  // TODO Images may be generated by code
}

function prepareImages() {
  for (let i = 0; i < images.textures.length; ++i) {
    const enclosedIndex = i;
    const img = document.getElementById('texture-' + i);

    img.addEventListener('click', () => {
      if (enclosedIndex == currentImage) {
        return;
      }

      document.getElementById('texture-' + currentImage).classList.remove('highlight');
      img.classList.add('highlight');
      currentImage = enclosedIndex;
    });
  }
}

function prepareVideoSources() {
  navigator.mediaDevices.enumerateDevices().then((devices) => {
    devices.forEach((device) => {
        let option = new Option();
        option.value = device.deviceId;

        if (device.kind == "videoinput") {
          option.text = device.label || `Camera ${videoSourcesSelect.length + 1}`;
          videoSourcesSelect.appendChild(option);  
        }
    });
  }).catch(function (e) {
    console.log(e.name + ": " + e.message);
  });
}

modelButton.addEventListener('click', modelButtonClicked);
async function modelButtonClicked() {
  tf.serialization.registerClass(ResizeLayer);
  model = await tf.loadLayersModel("model.json");

  modelButton.classList.add("removed");

  webcamButton.classList.remove("removed");
  document.getElementById("video-source-label").classList.remove("removed");
  document.getElementById("video-source").classList.remove("removed");
}

webcamButton.addEventListener('click', webcamButtonClicked);
function webcamButtonClicked() {
  document.getElementById("camera-icon").classList.add("removed");
  video.classList.remove("removed");

  document.getElementById("sofa-icon").classList.add("removed");
  canvasElement.classList.remove("removed");
  fps.classList.remove("removed");

  webcamButton.classList.add("removed");
  document.getElementById("video-source-label").classList.add("removed");
  document.getElementById("video-source").classList.add("removed");

  const videoSource = videoSourcesSelect.value;
  const constraints = {
    video: {
      width: ORIG_SIZE[0],
      height: ORIG_SIZE[1],
      deviceId: videoSource ? {exact: videoSource} : undefined
    }
  };

  navigator.mediaDevices.getUserMedia(constraints).then(async function(stream) {
    video.srcObject = stream;
    video.addEventListener('loadeddata', predictWebcam);
    webcam = await tf.data.webcam(video, {
      facingMode: "environment",
      deviceId: videoSource ? videoSource : undefined
    });
  });
}

async function predictWebcam() {
  if (webcam === undefined || images.tensors[currentImage] === undefined) {
    return;
  }

  const start = performance.now();

  const original = await webcam.capture();
  const img = tf.image.resizeBilinear(original, ORIG_SIZE);

  const predictions = tf.tidy(() => {
    const preds = tf.image.resizeBilinear(img, NN_SIZE).reshape([1, NN_SIZE[0], NN_SIZE[1], 3]);
    return tf.image.resizeBilinear(model.predict(preds), ORIG_SIZE);

    // const preds = tf.add(tf.mul(tf.cast(img, 'float32'), 2 / 255), -1);
    // const preds = tf.div(tf.cast(img, 'float32'), 255);
  });

  const imgArr = await img.array();
  const predArr = await predictions.array();
  const recolored = await recolor(imgArr, predArr, images.tensors[currentImage], ORIG_SIZE);

  tf.tidy(() => {
    tf.browser.toPixels(tf.tensor(recolored), canvasElement);
  });

  original.dispose();
  img.dispose();
  predictions.dispose();

  fps.textContent = "Elapsed time: " + (performance.now() - start) / 1000 + " seconds";

  window.requestAnimationFrame(predictWebcam);
}